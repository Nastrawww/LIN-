**Part 1: STM32 F407 is treatesd as a master**


STM32 as the Lin Master || Configure & Send Data
This tutorial is the PART1 in the small series covering the Lin protocol. In today’s tutorial we will configure the STM32 as the lin master, prepare the the data to be transmitted over the linbus and send the data. There will be no slave involved and the data will be monitored via the logic analyzer.

Basically we will see if the data transmitted is recognized as a valid lin frame by the analyzer. later in the upcoming tutorials we will connect an actual slave device and try to communicate with it.

I will be covering the lin version 2.1 in this series. As the the specification manual, a typical lin frame is shown in the picture below.
<img width="990" height="391" alt="image" src="https://github.com/user-attachments/assets/fa11979d-2c6a-418b-99b0-652e659bad27" />
The lin frame consists of the Header and the Response. The Header further contains the Break Field, the Sync Field and the Protected ID. The Response contains the Data bytes and the checksum byte.

**Break**
The break field is used to signal the beginning of a new frame. A break field is always generated by the master task (in the master node) and it shall be at least 13 nominal bit times of dominant value, followed by a break delimiter, as below.
<img width="1014" height="111" alt="image" src="https://github.com/user-attachments/assets/cfc83ad9-7744-413d-a3b2-f1e20b61c10b" />
**Sync**
Sync is a byte field with the data value 0x55 as shown in the image below.
<img width="997" height="119" alt="image" src="https://github.com/user-attachments/assets/345e3b14-2cd9-4b09-8f66-cc3e0bc227cc" />
**Protected ID**
A protected identifier field consists of two sub-fields: the frame identifier and the parity. Bits 0 to 5 are the frame identifier and bits 6 and 7 are the parity.
<img width="998" height="110" alt="image" src="https://github.com/user-attachments/assets/a641c351-733a-4502-b289-8fa450ef3329" />
Six bits are reserved for the frame identifier, values in the range 0 to 63 can be used. The frame identifiers are split in three categories:
Values 0 to 59 (0x3B) are used for signal carrying frames
60 (0x3C) and 61 (0x3D) are used to carry diagnostic and configuration data
62 (0x3E) and 63 (0x3F) are reserved for future protocol enhancements
The parity is calculated on the frame identifier bits as shown below:

P0 = ID0 ⊕ ID1 ⊕ ID2 ⊕ ID4
P1 = ¬(ID1 ⊕ ID3 ⊕ ID4 ⊕ ID5)

**Data**
A frame carries between one and eight bytes of data. A data byte is transmitted as part of a byte field. For data entities longer than one byte, the entity LSB is contained in the byte sent first and the entity MSB in the byte sent last (little-endian).
<img width="996" height="108" alt="image" src="https://github.com/user-attachments/assets/b2cad0bb-2e1f-4a72-af4a-ae6e41e5db39" />

**Checksum**
The last field of a frame is the checksum. The checksum contains the inverted eight bit sum with carry over all data bytes or all data bytes and the protected identifier. Checksum calculation over the data bytes and the protected identifier byte is called enhanced checksum and it is used for communication with LIN 2.x slaves. Use of classic or enhanced checksum is managed by the master node and it is determined per frame identifier; classic in communication with LIN 1.x slave nodes and enhanced in communication with LIN 2.x slave nodes.
A typical example of checksum calculation is shown below.
<img width="1094" height="610" alt="image" src="https://github.com/user-attachments/assets/af525a6f-29cc-42cf-9a05-e9e2bbb75922" />

**CubeMX Configuration**
Below is the image showing the configuration of the UART in the Lin mode.
<img width="611" height="603" alt="image" src="https://github.com/user-attachments/assets/26a5daa9-d300-434b-b6d4-82c878b3f537" />


The USART1 is configured in the Lin Mode. The Lin protocol supports the transfer up to the baud rate of 200 Kbps, but here I am using 9600 bps. The data size is set to 8 bits with no parity and 1 stop bit.

Below the image shows the Logic Analyser is connected to the USART1 TX pin (PA9).
<img width="1658" height="902" alt="image" src="https://github.com/user-attachments/assets/dbbeffec-e877-46f8-b7b9-75e935063364" />
Below is the Lin frame. We will send the data according to it.
<img width="990" height="391" alt="image" src="https://github.com/user-attachments/assets/87432d3a-587d-464f-9ea4-d307d27e1a10" />
The Break field will be sent by using the HAL function and the Sync field has the fixed value 0x55. We will prepare the Protected ID first and then the checksum.

**Protected ID**
I have already mentioned that the PID consists of two sub-fields: the frame identifier and the parity. Bits 0 to 5 are the frame identifier and bits 6 and 7 are the parity. The parity is calculated on the frame identifier bits as shown below:
P0 = ID0 ⊕ ID1 ⊕ ID2 ⊕ ID4
P1 = ¬(ID1 ⊕ ID3 ⊕ ID4 ⊕ ID5)

uint8_t pid_Calc (uint8_t ID)
{
if (ID > 0x3F) Error_Handler();
uint8_t IDBuf[6];
for (int i=0; i<6; i++)
{
IDBuf[i] = (ID>>i)&0x01;
}
uint8_t P0 = (IDBuf[0]^IDBuf[1]^IDBuf[2]^IDBuf[4])&0x01;
uint8_t P1 = ~((IDBuf[1]^IDBuf[3]^IDBuf[4]^IDBuf[5])&0x01);
ID = ID | (P0<<6) | (P1<<7);
return ID;
}
uint8_t pid_Calc (uint8_t ID)
{
	if (ID > 0x3F) Error_Handler();
	uint8_t IDBuf[6];
	for (int i=0; i<6; i++)
	{
		IDBuf[i] = (ID>>i)&0x01;
	}
	uint8_t P0 = (IDBuf[0]^IDBuf[1]^IDBuf[2]^IDBuf[4])&0x01;
	uint8_t P1 = ~((IDBuf[1]^IDBuf[3]^IDBuf[4]^IDBuf[5])&0x01);
	ID = ID | (P0<<6) | (P1<<7);
	return ID;
}
The function pid_Calc takes the actual ID as the parameter. We have only 6 bits for the ID, so if the ID is greater than 0x3F (63), we will call the error handler.

Here we will first extract each bit from the 6 bit ID and store them in the IDBuf.
The parity bit P0 will be calculated by performing the XOR operation between the ID 0 1 2 and 4.
Similarly, to calculate the parity bit P1, we will first perform the XOR operation between the ID 1 3 4 and 5, and then negate the value obtained.
Now we will add the parity bits with the actual ID and store the final value in the ID variable itself.
The value will then be returned.
Checksum
The checksum contains the inverted eight bit sum with carry over all data bytes or all data bytes and the protected identifier. Below is the method to calculate the Enhanced checksum.

uint8_t checksum_Calc (uint8_t PID, uint8_t *data, int size)
{
uint8_t buffer[size+2];
uint16_t sum = 0;
buffer[0] = PID;
for (int i=0; i<size; i++)
{
buffer[i+1] = data[i];
}

for (int i=0; i<size+1; i++)
{
sum += buffer[i];
if (sum>0xff) sum = sum-0xFF;
}

sum = 0xFF-sum;
return sum;
}
uint8_t checksum_Calc (uint8_t PID, uint8_t *data, int size)
{
	uint8_t buffer[size+2];
	uint16_t sum = 0;
	buffer[0] = PID;
	for (int i=0; i<size; i++)
	{
		buffer[i+1] = data[i];
	}

	for (int i=0; i<size+1; i++)
	{
		sum += buffer[i];
		if (sum>0xff) sum = sum-0xFF;
	}

	sum = 0xFF-sum;
	return sum;
}
The function checksum_Calc takes the following parameters:

@PID the protected ID
@*data the pointer to the actual data bytes
@size the size of the actual data
Since we need to add all the data bytes and the PID, we need to first store them in a single buffer. The buffer array is defined to do the same. The first element of the buffer array holds the PID value and the rest of them will store the data bytes.

Once we have all the data at once place, we will start adding it. The variable sum is 16 bit in size and it stores the result of the addition. Whenever the value of the sum is higher than 0xFF (255), we will subtract 0xFF from it.

After all the calculation is over, the sum variable will have a 8 bit result value in it. Finally we need to invert the result, so subtract the sum from 0xFF (255). This value will be returned in the end.

The main Function
Below is the code in the main function.

int main ()
{
...
...
while (1)
{

TxData[0] = 0x55; // sync field
TxData[1] = pid_Calc(0x34);
for (int i=0; i<8; i++)
{
TxData[i+2] = i;
}
TxData[10] = checksum_Calc(TxData[1], TxData+2, 8); //lin 2.1 includes PID, for line v1 use PID =0

HAL_LIN_SendBreak(&huart1);
HAL_UART_Transmit(&huart1, TxData, 11, 1000);
HAL_Delay(1000);
}

}
int main ()
{
  ...
  ...
  while (1)
  {

	  TxData[0] = 0x55;  // sync field
	  TxData[1] = pid_Calc(0x34);
	  for (int i=0; i<8; i++)
	  {
		  TxData[i+2] = i;
	  }
	  TxData[10] = checksum_Calc(TxData[1], TxData+2, 8);   //lin 2.1 includes PID, for line v1 use PID =0

	  HAL_LIN_SendBreak(&huart1);
	  HAL_UART_Transmit(&huart1, TxData, 11, 1000);
	  HAL_Delay(1000);
  }

}
We will send the TxData buffer via the UART, so we need to prepare it first.

First store the sync bytes (0x55) to the buffer.
The next element will contain the PID. Here I am using the ID 0x34, which will be then converted to the PID.
Then copy the data bytes to the buffer. I am storing 8 data bytes with the values starting from 0 to 7.
The last element of the buffer will contain the checksum.
I am using the Lin version 2.1, so the PID must be included in the checksum.
For the lin version 1.x, the PID is not needed and hence you can just pass the value 0 for the PID.
After preparing the TxData buffer, we will send it via the UART. The function HAL_LIN_SendBreak is used to send the break field. After sending the break field, we will send the TxData buffer.

Result
Below the image shows the frame captured on the logic analyser
<img width="1239" height="249" alt="image" src="https://github.com/user-attachments/assets/4dd985cc-be5b-4fc4-85ec-cccec9435ad9" />
ou can see the complete Lin frame in the image above.

The master sends the break field.
The sync field is sent next with the byte value of 0x55.
The third field is the PID. The MCU sends the PID 0xB4, but the ID 0x34 is extracted from it by the Lin analyzer.
The master then sends the 8 bytes of data. the data ranges from 0x00 to 0x07.
In the end, the master sends the checksum. This checksum value is correct otherwise the analyzer would have reported it as a wrong value.
So we have received the complete Lin frame at the output. This verifies that our program was correct and we can proceed with it.


 In this series we will cover different ways of transmitting and receiving data over the UART protocol. We will also see different UART modes available in the STM32 microcontrollers and how to use them.

This tutorial is the PART2 in the small series covering the Lin protocol. In today’s tutorial we will see how to connect a lin transceiver with the MCU. We will also use another MCU as the slave which will be connected to another lin transceiver. The data transfer will take place between the transceivers and it will be read by the slave MCU.

CP2004 The Lin Transceiver
I am going to use the microchip’s MCP2004 as the Lin transceiver. There is no specific reason to choose this IC, it was easily available so I am using it. You can also use MCP2003 as it is mostly similar to the MCP2004. Below is the pinout of the MCP2004.
<img width="551" height="296" alt="image" src="https://github.com/user-attachments/assets/10c9830a-a506-4fac-a2a1-b4fd5f87e5df" />

**RXD (RECEIVE DATA OUTPUT)** is an Open-Drain (OD) output This pin must be connected to the RX pin of the UART.

**CS (CHIP SELECT)** is used to enable or disable the transmitter mode of the transceiver. To enable the transmitter, this pin must be set to HIGH and to disable the transmitter, the pin must be LOW. We will connect this pin to the GPIO of the MCU.

**FAULT/TXE** pin is bidirectional and allows disabling of the transmitter, as well as Fault reporting related to disabling the transmitter. We will leave this pin disconnected.

**TXD** (TRANSMIT DATA INPUT) pin has an internal pull-up. The LIN pin is low (dominant) when TXD is low and high (recessive) when TXD is high. This pin must be connected to the TX pin of the UART.

**VSS** is the supply ground pin. We will connect it to the ground of the 12v supply.

**LBUS** is the bidirectional LIN Bus pin (LBUS) and is controlled by the TXD input. This pin will be connected to the LBUS of the another transceiver.

**VBB** is the Battery Positive Supply Voltage pin. We will connect it to the +12V supply.

**VREN** (VOLTAGE REGULATOR ENABLE OUTPUT) is the External Voltage Regulator Enable pin. We will leave this pin disconnected.

The Master
CubeMX Configuration
Below is the image showing the configuration of the UART in the Lin mode.
<img width="611" height="603" alt="image" src="https://github.com/user-attachments/assets/a9816d6f-dfbc-4f47-9cf8-2781901d51a9" />
The USART1 is configured in the Lin Mode. The Lin protocol supports the transfer up to the baud rate of 200 Kbps, but here I am using 9600 bps. The data size is set to 8 bits with no parity and 1 stop bit.

We also need to set a GPIO pin as the output. This will be used as the CS pin for the transceiver.
<img width="468" height="402" alt="image" src="https://github.com/user-attachments/assets/f165e33b-b65c-49e7-a858-3e8551c19819" />
Here I am setting the pin PC7 as the output pin.

Below is the code in the main function.

int indx = 0;

int main ()
{
...
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, 1); // Pull the cs pin HIGH to enable transmitter
while (1)
{

TxData[0] = 0x55; // sync field
TxData[1] = pid_Calc(0x34);
for (int i=0; i<8; i++)
{
TxData[i+2] = indx++;
if (indx>255) indx = 0;
}
TxData[10] = checksum_Calc(TxData[1], TxData+2, 8); //lin 2.1 includes PID, for line v1 use PID =0

HAL_LIN_SendBreak(&huart1);
HAL_UART_Transmit(&huart1, TxData, 11, 1000);
HAL_Delay(1000);
}

}
int indx = 0;

int main ()
{
  ...
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, 1);  // Pull the cs pin HIGH to enable transmitter
  while (1)
  {

	  TxData[0] = 0x55;  // sync field
	  TxData[1] = pid_Calc(0x34);
	  for (int i=0; i<8; i++)
	  {
		  TxData[i+2] = indx++;
                  if (indx>255) indx = 0;
	  }
	  TxData[10] = checksum_Calc(TxData[1], TxData+2, 8);   //lin 2.1 includes PID, for line v1 use PID =0

	  HAL_LIN_SendBreak(&huart1);
	  HAL_UART_Transmit(&huart1, TxData, 11, 1000);
	  HAL_Delay(1000);
  }

}
Since the master will be transmitting the data continuously, we would want to keep the transmitter mode enabled. This is why the CS pin is set to HIGH.

We will send the TxData buffer via the UART, so we need to prepare it first.
**First store the sync bytes (0x55) to the buffer.**

**The next element will contain the PID. Here I am using the ID 0x34, which will be then converted to the PID.**

**Then copy the data bytes to the buffer. I am storing 8 data bytes with the values starting from 0 to 7. The data bytes are just the values of the indx variable, which will keep incrementing.**

**The last element of the buffer will contain the checksum.**

I am using the Lin version 2.1, so the PID must be included in the checksum.
For the lin version 1.x, the PID is not needed and hence you can just pass the value 0 for the PID.
After preparing the TxData buffer, we will send it via the UART. The function HAL_LIN_SendBreak is used to send the break field. After sending the break field, we will send the TxData buffer.




 **Part:2**
**I am going to use the STM32F103C8T6 as the slave MCU. Below is the configuration of the slave MCU**



  
CubeMX Configuration
Below is the image showing the cubeMX configuration of the slave MCU.

<img width="1790" height="662" alt="image" src="https://github.com/user-attachments/assets/f98437cb-f5a8-4703-831b-113fe3c5e9cf" />
I am using the USART3 on the STM32F103C8T6. The USART is configured in the Lin Mode with the baud rate of 9600 bps, 8 data bits with 1 stop bit and no parity. This is basically the same configuration as we did in the master MCU.

I have also enabled the Global interrupt for the USART3 as I am going to receive the data in the interrupt mode.

Also make sure to enable the pull up for the RX pin in the GPIO setting. This is necessary or else the data will not be received. If your MCu does not support the internal pullup, connect an external pull up on this pin.

We also need to set a GPIO pin as the output. This will be used as the CS pin for the transceiver.

<img width="729" height="421" alt="image" src="https://github.com/user-attachments/assets/56a7005c-f2d7-4f19-8f07-c70f9acc4046" />

Here I am using the pin PB1 as the CS pin for the Transceiver IC.

The Code
We will start with receiving the data via the UART in the interrupt mode.

HAL_UARTEx_ReceiveToIdle_IT(&huart3, RxData, 20);

Here I am using the function receive to idle in the interrupt mode. So when all the 20 bytes has been received, or an idle line is detected before that, an interrupt will trigger and the RX Event Callback will be called.

We will process the received data inside this callback. Below is the image showing the data received by the slave in a single Lin frame.
<img width="643" height="224" alt="image" src="https://github.com/user-attachments/assets/95cc5bbb-af70-4165-853b-c3375ab3d3fa" />

The received bytes contains the following:

1 byte of the break field (0x00).
1 byte of the Sync field (0x55).
1 byte of the protected ID.
1 – 8 bytes of actual data.
1 byte of the checksum.
Basically other than the actual data bytes, we have 4 extra bytes containing other information. Since the master can send any number of actual data bytes between 1 to 8 bytes, we must have some means in the slave device to figure out how many actual data bytes were sent by the master.

void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
numDataBytes = Size - 4;
void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
	numDataBytes = Size - 4;
The variable numDataBytes will be used to track the actual number of data bytes received. The Size parameter of the callback contains the total bytes received and we have 4 additional bytes other than the data bytes. To extract the actual number of data bytes, we can simply use numDataBytes = Size – 4.

uint8_t checksum = checksum_Calc(RxData[2], RxData+3, numDataBytes);
if (checksum != RxData[Size-1])
{
isDataValid = 0;
// call error handler
}
else isDataValid = 1;
	uint8_t checksum = checksum_Calc(RxData[2], RxData+3, numDataBytes);
	if (checksum != RxData[Size-1])
	{
		isDataValid = 0;
		// call error handler
	}
	else isDataValid = 1;
We can check the validity of the received data by calculating the checksum. The actual data starts from the offset of 3, and the total number of data bytes has already been calculated.

We will verify this checksum with the received checksum. If it is same, that means the received data is valid and we can process it. Here we will set the variable isDataValid to 1 so that we can later process the data in the while loop.

ID = RxData[2]&0x3F;
	ID = RxData[2]&0x3F;
We can also extract the actual ID from the protected ID. We know that the protected ID is made up of 6 bits of the actual ID and the 2 parity bits (P0 & P1). So to extract the actual ID from the PID, we can simply extract the first 6 bits from it.

HAL_UARTEx_ReceiveToIdle_IT(&huart3, RxData, 20);
}
	HAL_UARTEx_ReceiveToIdle_IT(&huart3, RxData, 20);
}
Finally we will call the receive to idle function again, so that we have the continuous reception of data.

We will process the data in the while loop.

while (1)
{
if (isDataValid == 1)
{
for (int i=0; i<numDataBytes; i++)
{
Data[i] = RxData[i+3];
}
isDataValid = 0;
}
}
  while (1)
  {
	  if (isDataValid == 1)
	  {
		  for (int i=0; i<numDataBytes; i++)
		  {
			  Data[i] = RxData[i+3];
		  }
		  isDataValid = 0;
	  }
  }
Here we will check if the isDataValid variable is set to 1. If it is, then we will copy the received data from the RX buffer to the Data buffer. We can process this data buffer in any way we want.

Also set the isDataValid variable to 0, so that this loop does not run again.




**Connection
Below is the image showing the connection between the MCUs and their respective transceivers.**
<img width="2890" height="849" alt="image" src="https://github.com/user-attachments/assets/cedaf290-a72d-474b-ad20-00939e67af9c" />
The UART TX pins are connected to the transceiver TX pins and the UART RX pins are connected to the transceiver RX pins. The pin 2 of the transceiver is the CS pin and it is connected to the respective GPIO on the MCU.

The Lin bus of the transceivers are connected together as it will transmit and receive the signal.

The transceivers are powered using 12V from the battery.
Below the images shows the data received by the slave MCU and the actual data extracted from the received data.
<img width="513" height="164" alt="image" src="https://github.com/user-attachments/assets/19f4ee62-dc4d-4f04-af32-45366038757b" />

The slave received a total of 12 bytes of data. The received data contains the following:

The break field 0x00.
The sync field 0x55.
The PID 0xB4.
8 Data bytes.
The checksum byte.
The Data buffer contains the 8 data bytes extracted from the RX buffer.















